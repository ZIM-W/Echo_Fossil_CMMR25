/*  ESP32‑S3 DevKitC‑1 · 10‑Touch + DF‑A/DF‑B
 *  ─────────────────────────────────────────────
 *  DF‑A  背景 0001.mp3 一直循环（VOL_FULL）
 *  DF‑B  同时触摸 N 根 → 播放 000N.mp3 (VOL_FULL)
 *        触摸数变就立即 stop+play；松手 stop+mute
 */

#include <Arduino.h>
#include <DFRobotDFPlayerMini.h>
#include <esp32-hal-touch.h>
#include <math.h>

/* —— 配置 —— */
const uint8_t TOUCH_PINS[] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };
const uint8_t N_CH = sizeof(TOUCH_PINS);
const float DELTA_TOUCH = 0.05f;  // ≥5 % 变化算触摸
const uint32_t SCAN_MS = 50;
const uint32_t DRIFT_MS = 15000;  // 无触摸漂移
const uint8_t VOL_FULL = 25;
const uint8_t VOL_MUTE = 0;

/* —— 硬件串口 —— */
HardwareSerial mp3A(2);  // UART2  38 / 39
HardwareSerial mp3B(1);  // UART1  40 / 41
DFRobotDFPlayerMini dfA, dfB;

/* —— 全局状态 —— */
uint16_t base[N_CH];
uint8_t curCount = 0;
uint32_t lastTouchMs = 0;

/* ---------- 打印曲目 ---------- */
void logTrack(const char* tag, uint16_t n) {
  char f[10];
  sprintf(f, "%04u.mp3", n);
  Serial.printf("%s -> %s\n", tag, f);
}

/* ---------- 校准 ---------- */
void calibrate() {
  for (uint8_t i = 0; i < N_CH; i++) {
    uint32_t s = 0;
    for (uint8_t n = 0; n < 8; n++) {
      s += touchRead(TOUCH_PINS[i]);
      delay(6);
    }
    base[i] = s / 8;
  }
  lastTouchMs = millis();
}

/* ---------- 计数触摸 ---------- */
uint8_t countTouch(bool& any) {
  uint8_t c = 0;
  any = false;
  for (uint8_t i = 0; i < N_CH; i++) {
    float d = fabsf((float)touchRead(TOUCH_PINS[i]) - base[i]) / base[i];
    if (d >= DELTA_TOUCH) {
      ++c;
      any = true;
    }
  }
  return c;
}

/* ---------- SETUP ---------- */
void setup() {
  Serial.begin(115200);

  mp3A.begin(9600, SERIAL_8N1, 38, 39);  // RX,TX
  mp3B.begin(9600, SERIAL_8N1, 40, 41);  // RX,TX

  if (!dfA.begin(mp3A, false, false) || !dfB.begin(mp3B, false, false)) {
    while (1) {
      Serial.println("DF init fail");
      delay(1000);
    }
  }
  dfA.volume(VOL_FULL);
  dfA.enableLoop();

  dfA.loop(1);  // 背景 0001.mp3
  logTrack("BG", 1);

  dfB.volume(VOL_MUTE);  // 默认静音
  dfB.enableLoop();

  calibrate();
  dfA.stop();
  dfB.stop();
}

/* ---------- LOOP ---------- */
void loop() {
  static uint32_t scanT = 0;
  if (millis() - scanT >= SCAN_MS) {
    scanT = millis();
    bool any = false;
    uint8_t cnt = countTouch(any);

    /* 串口打印触摸数组 */
    Serial.print("[");
    for (uint8_t i = 0; i < N_CH; i++) {
      float d = fabsf((float)touchRead(TOUCH_PINS[i]) - base[i]) / base[i];
      Serial.print(d >= DELTA_TOUCH ? '1' : '0');
      if (i < N_CH - 1) Serial.print(',');
    }
    Serial.printf("] Count=%u\n", cnt);

    /* —— 前景控制逻辑 —— */
    if (cnt == 0 && curCount != 0) {  // 松手 → 停 DF‑B
      dfB.stop();
      dfB.volume(VOL_MUTE);
      curCount = 0;
      Serial.println("FG stop (no touch)");
    } else if (cnt > 0 && cnt != curCount) {  // 数量变化 → 切曲
      curCount = cnt;
      dfB.stop();
      dfB.volume(VOL_FULL);
      dfB.play(curCount);  // 文件 000N.mp3
      logTrack("FG", curCount);
    }

    /* —— 漂移补偿 —— */
    if (!any && millis() - lastTouchMs > DRIFT_MS) {
      for (uint8_t i = 0; i < N_CH; i++) {
        uint16_t raw = touchRead(TOUCH_PINS[i]);
        base[i] = (base[i] * 7 + raw) >> 3;  // EMA
      }
      lastTouchMs = millis();
      Serial.println("Baseline drift adjust");
    }
  }
}
