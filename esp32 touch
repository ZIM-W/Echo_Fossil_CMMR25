/*  ESP32 10-Touch + DF-A / DF-B
 *  -----------------------------------------------------------
 *  DF-A: Background track "0001.mp3" plays in 100% loop
 *  DF-B: When N touch points are active → play "000N.mp3" at 100% volume  (N = 1-10)
 *        If N changes, switch track immediately; if N = 0, stop playback and mute immediately
 *  Touch GPIO: 4-13   ·  Auto direction adaptation  ·  15 s idle drift correction
 *  Serial: 115200  → prints touch array + current BG / FG file
 *  UART: DF-A  RX=39  TX=38   ·  DF-B  RX=41  TX=40
 *        Both RX lines → DFPlayer RX via 1 kΩ resistor
 */

#include <Arduino.h>
#include <DFRobotDFPlayerMini.h>
#include <esp32-hal-touch.h>
#include <math.h>

/* ——— USER PARAMETERS ——— */
const uint8_t TOUCH_PINS[] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 };
const uint8_t N_CH = sizeof(TOUCH_PINS);
const float DELTA_TOUCH = 0.05f;  // ≥5 % change counts as a touch
const uint32_t SCAN_MS = 50;      // touch scan interval
const uint32_t DRIFT_MS = 15000;  // drift adjustment after 15 s no touch
const uint8_t VOL_FULL = 25;      // full volume
const uint8_t VOL_MUTE = 0;       // mute

/* ——— HARDWARE SERIAL & DFPLAYER ——— */
HardwareSerial mp3A(2);  // UART2 (RX=39 TX=38)
HardwareSerial mp3B(1);  // UART1 (RX=41 TX=40)
DFRobotDFPlayerMini dfA, dfB;

/* ——— GLOBAL STATE ——— */
uint16_t base[N_CH];
uint8_t curCount = 0;  // current number of touches
uint32_t lastTouchMs = 0;

int dfAstate = 0;
int dfBstate = 0;

/* ---------- PRINT TRACK INFO ---------- */
void logTrack(const char* tag, uint16_t n) {
  char buf[10];
  sprintf(buf, "%04u.mp3", n);
  Serial.printf("%s -> %s\n", tag, buf);
}

/* ---------- CALIBRATION ---------- */
void calibrate() {
  for (uint8_t i = 0; i < N_CH; ++i) {
    uint32_t s = 0;
    for (uint8_t n = 0; n < 8; ++n) {
      s += touchRead(TOUCH_PINS[i]);
      delay(6);
    }
    base[i] = s / 8;
  }
  lastTouchMs = millis();
}

/* ---------- COUNT TOUCHES ---------- */
uint8_t countTouch(bool& any) {
  uint8_t c = 0;
  any = false;
  for (uint8_t i = 0; i < N_CH; ++i) {
    float diff = fabsf((float)touchRead(TOUCH_PINS[i]) - base[i]) / base[i];
    if (diff >= DELTA_TOUCH) {
      ++c;
      any = true;
    }
  }
  return c;
}

/* ---------- ARDUINO SETUP ---------- */
void setup() {
  Serial.begin(115200);

  mp3A.begin(9600, SERIAL_8N1, 39, 38);  // DF-A
  mp3B.begin(9600, SERIAL_8N1, 41, 40);  // DF-B

  if (!dfA.begin(mp3A, false, false) || !dfB.begin(mp3B, false, false)) {
    while (1) {
      Serial.println("DF initialization failed");
      delay(1000);
    }
  }

  dfA.stop();
  dfB.stop();

  dfA.enableLoop();
  dfB.enableLoop();
  dfA.enableDAC();
  dfB.enableDAC();
  delay(100);

  dfA.volume(VOL_FULL);
  dfA.loop(1);  // background track 0001.mp3
  logTrack("BG", 1);
  dfB.volume(VOL_MUTE);  // start muted

  calibrate();
  delay(100);
}

/* ---------- ARDUINO LOOP ---------- */
void loop() {
  static uint32_t scanT = 0;
  if (millis() - scanT >= SCAN_MS) {
    scanT = millis();
    bool any = false;
    uint8_t cnt = countTouch(any);

    /* Print touch array over serial */
    Serial.print("[");
    for (uint8_t i = 0; i < N_CH; ++i) {
      float d = fabsf((float)touchRead(TOUCH_PINS[i]) - base[i]) / base[i];
      Serial.print(d >= DELTA_TOUCH ? '1' : '0');
      if (i < N_CH - 1) Serial.print(',');
    }
    Serial.printf("] Count=%u\n", cnt);

    /* Background watchdog: DF-A not playing → restart loop */
    if (dfA.available()) { dfAstate = dfA.readState(); }
    if (dfB.available()) { dfBstate = dfB.readState(); }
    if (dfAstate == 0) {
      dfA.loop(1);
      logTrack("BG", 1);
      dfAstate = 1;
    }
    if (dfBstate == 0) {
      dfB.play(curCount + 1);
      logTrack("FG", curCount + 1);
      dfBstate = 1;
    }

    /* —— FOREGROUND DF-B CONTROL —— */
    if (cnt == 0) {  // no touch → stop playback
      dfB.stop();
      dfB.volume(VOL_MUTE);
      curCount = 0;
      Serial.println("FG stop (no touch)");
    } else if (cnt > 0 && cnt != curCount) {  // touch count changed → switch track
      curCount = cnt;
      dfB.stop();
      dfB.volume(VOL_FULL);
      dfB.play(curCount + 1);  // play file 000N.mp3
      logTrack("FG", curCount + 1);
    }

    /* —— DRIFT COMPENSATION —— */
    if (!any && millis() - lastTouchMs > DRIFT_MS) {
      for (uint8_t i = 0; i < N_CH; ++i) {
        uint16_t raw = touchRead(TOUCH_PINS[i]);
        base[i] = (base[i] * 7 + raw) >> 3;  // exponential moving average α=1/8
      }
      lastTouchMs = millis();
      Serial.println("Baseline drift adjusted");
    }
  }
}
